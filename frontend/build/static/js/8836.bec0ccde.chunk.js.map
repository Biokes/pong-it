{"version":3,"file":"static/js/8836.bec0ccde.chunk.js","mappings":"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","sources":["../../node_modules/viem/utils/abi/prepareEncodeFunctionData.ts","../../node_modules/viem/utils/abi/encodeFunctionData.ts","../../node_modules/viem/errors/typedData.ts","../../node_modules/viem/utils/typedData.ts","../../node_modules/viem/utils/signature/hashTypedData.ts","../../node_modules/viem/constants/strings.ts","../../node_modules/viem/utils/signature/hashMessage.ts","../../node_modules/viem/utils/signature/toPrefixedMessage.ts","../../node_modules/viem/utils/abi/getAbiItem.ts","../../node_modules/viem/utils/hash/toFunctionSelector.ts","../../node_modules/viem/node_modules/abitype/src/regex.ts","../../node_modules/viem/utils/data/concat.ts","../../node_modules/viem/utils/data/slice.ts","../../node_modules/viem/utils/abi/formatAbiItem.ts","../../node_modules/viem/errors/abi.ts","../../node_modules/viem/node_modules/abitype/src/human-readable/formatAbiParameter.ts","../../node_modules/viem/node_modules/abitype/src/human-readable/formatAbiParameters.ts","../../node_modules/viem/utils/abi/encodeAbiParameters.ts","../../node_modules/viem/node_modules/abitype/src/human-readable/formatAbiItem.ts","../../node_modules/viem/utils/hash/toEventSelector.ts","../../node_modules/viem/utils/regex.ts","../../node_modules/viem/utils/hash/hashSignature.ts","../../node_modules/viem/utils/hash/toSignature.ts","../../node_modules/viem/utils/hash/normalizeSignature.ts","../../node_modules/viem/utils/hash/toSignatureHash.ts"],"sourcesContent":["import type {\n  Abi,\n  AbiStateMutability,\n  ExtractAbiFunction,\n  ExtractAbiFunctions,\n} from 'abitype'\n\nimport {\n  AbiFunctionNotFoundError,\n  type AbiFunctionNotFoundErrorType,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  ContractFunctionArgs,\n  ContractFunctionName,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { IsNarrowable, UnionEvaluate } from '../../types/utils.js'\nimport type { ConcatHexErrorType } from '../data/concat.js'\nimport {\n  type ToFunctionSelectorErrorType,\n  toFunctionSelector,\n} from '../hash/toFunctionSelector.js'\nimport { type FormatAbiItemErrorType, formatAbiItem } from './formatAbiItem.js'\nimport { type GetAbiItemErrorType, getAbiItem } from './getAbiItem.js'\n\nconst docsPath = '/docs/contract/encodeFunctionData'\n\nexport type PrepareEncodeFunctionDataParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends\n    | ContractFunctionName<abi>\n    | undefined = ContractFunctionName<abi>,\n  ///\n  hasFunctions = abi extends Abi\n    ? Abi extends abi\n      ? true\n      : [ExtractAbiFunctions<abi>] extends [never]\n        ? false\n        : true\n    : true,\n  allArgs = ContractFunctionArgs<\n    abi,\n    AbiStateMutability,\n    functionName extends ContractFunctionName<abi>\n      ? functionName\n      : ContractFunctionName<abi>\n  >,\n  allFunctionNames = ContractFunctionName<abi>,\n> = {\n  abi: abi\n} & UnionEvaluate<\n  IsNarrowable<abi, Abi> extends true\n    ? abi['length'] extends 1\n      ? { functionName?: functionName | allFunctionNames | Hex | undefined }\n      : { functionName: functionName | allFunctionNames | Hex }\n    : { functionName?: functionName | allFunctionNames | Hex | undefined }\n> &\n  UnionEvaluate<{ args?: allArgs | undefined }> &\n  (hasFunctions extends true ? unknown : never)\n\nexport type PrepareEncodeFunctionDataReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends\n    | ContractFunctionName<abi>\n    | undefined = ContractFunctionName<abi>,\n> = {\n  abi: abi extends Abi\n    ? functionName extends ContractFunctionName<abi>\n      ? [ExtractAbiFunction<abi, functionName>]\n      : abi\n    : Abi\n  functionName: Hex\n}\n\nexport type PrepareEncodeFunctionDataErrorType =\n  | AbiFunctionNotFoundErrorType\n  | ConcatHexErrorType\n  | FormatAbiItemErrorType\n  | GetAbiItemErrorType\n  | ToFunctionSelectorErrorType\n  | ErrorType\n\nexport function prepareEncodeFunctionData<\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi> | undefined = undefined,\n>(\n  parameters: PrepareEncodeFunctionDataParameters<abi, functionName>,\n): PrepareEncodeFunctionDataReturnType<abi, functionName> {\n  const { abi, args, functionName } =\n    parameters as PrepareEncodeFunctionDataParameters\n\n  let abiItem = abi[0]\n  if (functionName) {\n    const item = getAbiItem({\n      abi,\n      args,\n      name: functionName,\n    })\n    if (!item) throw new AbiFunctionNotFoundError(functionName, { docsPath })\n    abiItem = item\n  }\n\n  if (abiItem.type !== 'function')\n    throw new AbiFunctionNotFoundError(undefined, { docsPath })\n\n  return {\n    abi: [abiItem],\n    functionName: toFunctionSelector(formatAbiItem(abiItem)),\n  } as unknown as PrepareEncodeFunctionDataReturnType<abi, functionName>\n}\n","import type { Abi, AbiStateMutability, ExtractAbiFunctions } from 'abitype'\n\nimport type { AbiFunctionNotFoundErrorType } from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  ContractFunctionArgs,\n  ContractFunctionName,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { IsNarrowable, UnionEvaluate } from '../../types/utils.js'\nimport { type ConcatHexErrorType, concatHex } from '../data/concat.js'\nimport type { ToFunctionSelectorErrorType } from '../hash/toFunctionSelector.js'\nimport {\n  type EncodeAbiParametersErrorType,\n  encodeAbiParameters,\n} from './encodeAbiParameters.js'\nimport type { FormatAbiItemErrorType } from './formatAbiItem.js'\nimport type { GetAbiItemErrorType } from './getAbiItem.js'\nimport { prepareEncodeFunctionData } from './prepareEncodeFunctionData.js'\n\nexport type EncodeFunctionDataParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends\n    | ContractFunctionName<abi>\n    | Hex\n    | undefined = ContractFunctionName<abi>,\n  ///\n  hasFunctions = abi extends Abi\n    ? Abi extends abi\n      ? true\n      : [ExtractAbiFunctions<abi>] extends [never]\n        ? false\n        : true\n    : true,\n  allArgs = ContractFunctionArgs<\n    abi,\n    AbiStateMutability,\n    functionName extends ContractFunctionName<abi>\n      ? functionName\n      : ContractFunctionName<abi>\n  >,\n  allFunctionNames = ContractFunctionName<abi>,\n> = {\n  abi: abi\n} & UnionEvaluate<\n  IsNarrowable<abi, Abi> extends true\n    ? abi['length'] extends 1\n      ? { functionName?: functionName | allFunctionNames | Hex | undefined }\n      : { functionName: functionName | allFunctionNames | Hex }\n    : { functionName?: functionName | allFunctionNames | Hex | undefined }\n> &\n  UnionEvaluate<\n    readonly [] extends allArgs\n      ? { args?: allArgs | undefined }\n      : { args: allArgs }\n  > &\n  (hasFunctions extends true ? unknown : never)\n\nexport type EncodeFunctionDataReturnType = Hex\n\nexport type EncodeFunctionDataErrorType =\n  | AbiFunctionNotFoundErrorType\n  | ConcatHexErrorType\n  | EncodeAbiParametersErrorType\n  | FormatAbiItemErrorType\n  | GetAbiItemErrorType\n  | ToFunctionSelectorErrorType\n  | ErrorType\n\nexport function encodeFunctionData<\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi> | undefined = undefined,\n>(\n  parameters: EncodeFunctionDataParameters<abi, functionName>,\n): EncodeFunctionDataReturnType {\n  const { args } = parameters as EncodeFunctionDataParameters\n\n  const { abi, functionName } = (() => {\n    if (\n      parameters.abi.length === 1 &&\n      parameters.functionName?.startsWith('0x')\n    )\n      return parameters as { abi: Abi; functionName: Hex }\n    return prepareEncodeFunctionData(parameters)\n  })()\n\n  const abiItem = abi[0]\n  const signature = functionName\n\n  const data =\n    'inputs' in abiItem && abiItem.inputs\n      ? encodeAbiParameters(abiItem.inputs, args ?? [])\n      : undefined\n  return concatHex([signature, data ?? '0x'])\n}\n","import type { TypedData } from 'abitype'\n\nimport { stringify } from '../utils/stringify.js'\nimport { BaseError } from './base.js'\n\nexport type InvalidDomainErrorType = InvalidDomainError & {\n  name: 'InvalidDomainError'\n}\nexport class InvalidDomainError extends BaseError {\n  constructor({ domain }: { domain: unknown }) {\n    super(`Invalid domain \"${stringify(domain)}\".`, {\n      metaMessages: ['Must be a valid EIP-712 domain.'],\n    })\n  }\n}\n\nexport type InvalidPrimaryTypeErrorType = InvalidPrimaryTypeError & {\n  name: 'InvalidPrimaryTypeError'\n}\nexport class InvalidPrimaryTypeError extends BaseError {\n  constructor({\n    primaryType,\n    types,\n  }: { primaryType: string; types: TypedData | Record<string, unknown> }) {\n    super(\n      `Invalid primary type \\`${primaryType}\\` must be one of \\`${JSON.stringify(Object.keys(types))}\\`.`,\n      {\n        docsPath: '/api/glossary/Errors#typeddatainvalidprimarytypeerror',\n        metaMessages: ['Check that the primary type is a key in `types`.'],\n      },\n    )\n  }\n}\n\nexport type InvalidStructTypeErrorType = InvalidStructTypeError & {\n  name: 'InvalidStructTypeError'\n}\nexport class InvalidStructTypeError extends BaseError {\n  constructor({ type }: { type: string }) {\n    super(`Struct type \"${type}\" is invalid.`, {\n      metaMessages: ['Struct type must not be a Solidity type.'],\n      name: 'InvalidStructTypeError',\n    })\n  }\n}\n","import type { TypedData, TypedDataDomain, TypedDataParameter } from 'abitype'\n\nimport { BytesSizeMismatchError } from '../errors/abi.js'\nimport { InvalidAddressError } from '../errors/address.js'\nimport {\n  InvalidDomainError,\n  InvalidPrimaryTypeError,\n  InvalidStructTypeError,\n} from '../errors/typedData.js'\nimport type { ErrorType } from '../errors/utils.js'\nimport type { Hex } from '../types/misc.js'\nimport type { TypedDataDefinition } from '../types/typedData.js'\nimport { type IsAddressErrorType, isAddress } from './address/isAddress.js'\nimport { type SizeErrorType, size } from './data/size.js'\nimport { type NumberToHexErrorType, numberToHex } from './encoding/toHex.js'\nimport { bytesRegex, integerRegex } from './regex.js'\nimport {\n  type HashDomainErrorType,\n  hashDomain,\n} from './signature/hashTypedData.js'\nimport { stringify } from './stringify.js'\n\nexport type SerializeTypedDataErrorType =\n  | HashDomainErrorType\n  | IsAddressErrorType\n  | NumberToHexErrorType\n  | SizeErrorType\n  | ErrorType\n\nexport function serializeTypedData<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(parameters: TypedDataDefinition<typedData, primaryType>) {\n  const {\n    domain: domain_,\n    message: message_,\n    primaryType,\n    types,\n  } = parameters as unknown as TypedDataDefinition\n\n  const normalizeData = (\n    struct: readonly TypedDataParameter[],\n    data_: Record<string, unknown>,\n  ) => {\n    const data = { ...data_ }\n    for (const param of struct) {\n      const { name, type } = param\n      if (type === 'address') data[name] = (data[name] as string).toLowerCase()\n    }\n    return data\n  }\n\n  const domain = (() => {\n    if (!types.EIP712Domain) return {}\n    if (!domain_) return {}\n    return normalizeData(types.EIP712Domain, domain_)\n  })()\n\n  const message = (() => {\n    if (primaryType === 'EIP712Domain') return undefined\n    return normalizeData(types[primaryType], message_)\n  })()\n\n  return stringify({ domain, message, primaryType, types })\n}\n\nexport type ValidateTypedDataErrorType =\n  | HashDomainErrorType\n  | IsAddressErrorType\n  | NumberToHexErrorType\n  | SizeErrorType\n  | ErrorType\n\nexport function validateTypedData<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(parameters: TypedDataDefinition<typedData, primaryType>) {\n  const { domain, message, primaryType, types } =\n    parameters as unknown as TypedDataDefinition\n\n  const validateData = (\n    struct: readonly TypedDataParameter[],\n    data: Record<string, unknown>,\n  ) => {\n    for (const param of struct) {\n      const { name, type } = param\n      const value = data[name]\n\n      const integerMatch = type.match(integerRegex)\n      if (\n        integerMatch &&\n        (typeof value === 'number' || typeof value === 'bigint')\n      ) {\n        const [_type, base, size_] = integerMatch\n        // If number cannot be cast to a sized hex value, it is out of range\n        // and will throw.\n        numberToHex(value, {\n          signed: base === 'int',\n          size: Number.parseInt(size_, 10) / 8,\n        })\n      }\n\n      if (type === 'address' && typeof value === 'string' && !isAddress(value))\n        throw new InvalidAddressError({ address: value })\n\n      const bytesMatch = type.match(bytesRegex)\n      if (bytesMatch) {\n        const [_type, size_] = bytesMatch\n        if (size_ && size(value as Hex) !== Number.parseInt(size_, 10))\n          throw new BytesSizeMismatchError({\n            expectedSize: Number.parseInt(size_, 10),\n            givenSize: size(value as Hex),\n          })\n      }\n\n      const struct = types[type]\n      if (struct) {\n        validateReference(type)\n        validateData(struct, value as Record<string, unknown>)\n      }\n    }\n  }\n\n  // Validate domain types.\n  if (types.EIP712Domain && domain) {\n    if (typeof domain !== 'object') throw new InvalidDomainError({ domain })\n    validateData(types.EIP712Domain, domain)\n  }\n\n  // Validate message types.\n  if (primaryType !== 'EIP712Domain') {\n    if (types[primaryType]) validateData(types[primaryType], message)\n    else throw new InvalidPrimaryTypeError({ primaryType, types })\n  }\n}\n\nexport type GetTypesForEIP712DomainErrorType = ErrorType\n\nexport function getTypesForEIP712Domain({\n  domain,\n}: {\n  domain?: TypedDataDomain | undefined\n}): TypedDataParameter[] {\n  return [\n    typeof domain?.name === 'string' && { name: 'name', type: 'string' },\n    domain?.version && { name: 'version', type: 'string' },\n    (typeof domain?.chainId === 'number' ||\n      typeof domain?.chainId === 'bigint') && {\n      name: 'chainId',\n      type: 'uint256',\n    },\n    domain?.verifyingContract && {\n      name: 'verifyingContract',\n      type: 'address',\n    },\n    domain?.salt && { name: 'salt', type: 'bytes32' },\n  ].filter(Boolean) as TypedDataParameter[]\n}\n\nexport type DomainSeparatorErrorType =\n  | GetTypesForEIP712DomainErrorType\n  | HashDomainErrorType\n  | ErrorType\n\nexport function domainSeparator({ domain }: { domain: TypedDataDomain }): Hex {\n  return hashDomain({\n    domain,\n    types: {\n      EIP712Domain: getTypesForEIP712Domain({ domain }),\n    },\n  })\n}\n\n/** @internal */\nfunction validateReference(type: string) {\n  // Struct type must not be a Solidity type.\n  if (\n    type === 'address' ||\n    type === 'bool' ||\n    type === 'string' ||\n    type.startsWith('bytes') ||\n    type.startsWith('uint') ||\n    type.startsWith('int')\n  )\n    throw new InvalidStructTypeError({ type })\n}\n","// Implementation forked and adapted from https://github.com/MetaMask/eth-sig-util/blob/main/src/sign-typed-data.ts\n\nimport type { AbiParameter, TypedData, TypedDataDomain } from 'abitype'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { TypedDataDefinition } from '../../types/typedData.js'\nimport {\n  type EncodeAbiParametersErrorType,\n  encodeAbiParameters,\n} from '../abi/encodeAbiParameters.js'\nimport { concat } from '../data/concat.js'\nimport { type ToHexErrorType, toHex } from '../encoding/toHex.js'\nimport { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'\nimport {\n  type GetTypesForEIP712DomainErrorType,\n  getTypesForEIP712Domain,\n  type ValidateTypedDataErrorType,\n  validateTypedData,\n} from '../typedData.js'\n\ntype MessageTypeProperty = {\n  name: string\n  type: string\n}\n\nexport type HashTypedDataParameters<\n  typedData extends TypedData | Record<string, unknown> = TypedData,\n  primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,\n> = TypedDataDefinition<typedData, primaryType>\n\nexport type HashTypedDataReturnType = Hex\n\nexport type HashTypedDataErrorType =\n  | GetTypesForEIP712DomainErrorType\n  | HashDomainErrorType\n  | HashStructErrorType\n  | ValidateTypedDataErrorType\n  | ErrorType\n\nexport function hashTypedData<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(\n  parameters: HashTypedDataParameters<typedData, primaryType>,\n): HashTypedDataReturnType {\n  const {\n    domain = {},\n    message,\n    primaryType,\n  } = parameters as HashTypedDataParameters\n  const types = {\n    EIP712Domain: getTypesForEIP712Domain({ domain }),\n    ...parameters.types,\n  }\n\n  // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n  // as we can't statically check this with TypeScript.\n  validateTypedData({\n    domain,\n    message,\n    primaryType,\n    types,\n  })\n\n  const parts: Hex[] = ['0x1901']\n  if (domain)\n    parts.push(\n      hashDomain({\n        domain,\n        types: types as Record<string, MessageTypeProperty[]>,\n      }),\n    )\n\n  if (primaryType !== 'EIP712Domain')\n    parts.push(\n      hashStruct({\n        data: message,\n        primaryType,\n        types: types as Record<string, MessageTypeProperty[]>,\n      }),\n    )\n\n  return keccak256(concat(parts))\n}\n\nexport type HashDomainErrorType = HashStructErrorType | ErrorType\n\nexport function hashDomain({\n  domain,\n  types,\n}: {\n  domain: TypedDataDomain\n  types: Record<string, MessageTypeProperty[]>\n}) {\n  return hashStruct({\n    data: domain,\n    primaryType: 'EIP712Domain',\n    types,\n  })\n}\n\nexport type HashStructErrorType =\n  | EncodeDataErrorType\n  | Keccak256ErrorType\n  | ErrorType\n\nexport function hashStruct({\n  data,\n  primaryType,\n  types,\n}: {\n  data: Record<string, unknown>\n  primaryType: string\n  types: Record<string, readonly MessageTypeProperty[]>\n}) {\n  const encoded = encodeData({\n    data,\n    primaryType,\n    types,\n  })\n  return keccak256(encoded)\n}\n\ntype EncodeDataErrorType =\n  | EncodeAbiParametersErrorType\n  | EncodeFieldErrorType\n  | HashTypeErrorType\n  | ErrorType\n\nfunction encodeData({\n  data,\n  primaryType,\n  types,\n}: {\n  data: Record<string, unknown>\n  primaryType: string\n  types: Record<string, readonly MessageTypeProperty[]>\n}) {\n  const encodedTypes: AbiParameter[] = [{ type: 'bytes32' }]\n  const encodedValues: unknown[] = [hashType({ primaryType, types })]\n\n  for (const field of types[primaryType]) {\n    const [type, value] = encodeField({\n      types,\n      name: field.name,\n      type: field.type,\n      value: data[field.name],\n    })\n    encodedTypes.push(type)\n    encodedValues.push(value)\n  }\n\n  return encodeAbiParameters(encodedTypes, encodedValues)\n}\n\ntype HashTypeErrorType =\n  | ToHexErrorType\n  | EncodeTypeErrorType\n  | Keccak256ErrorType\n  | ErrorType\n\nfunction hashType({\n  primaryType,\n  types,\n}: {\n  primaryType: string\n  types: Record<string, readonly MessageTypeProperty[]>\n}) {\n  const encodedHashType = toHex(encodeType({ primaryType, types }))\n  return keccak256(encodedHashType)\n}\n\ntype EncodeTypeErrorType = FindTypeDependenciesErrorType\n\nexport function encodeType({\n  primaryType,\n  types,\n}: {\n  primaryType: string\n  types: Record<string, readonly MessageTypeProperty[]>\n}) {\n  let result = ''\n  const unsortedDeps = findTypeDependencies({ primaryType, types })\n  unsortedDeps.delete(primaryType)\n\n  const deps = [primaryType, ...Array.from(unsortedDeps).sort()]\n  for (const type of deps) {\n    result += `${type}(${types[type]\n      .map(({ name, type: t }) => `${t} ${name}`)\n      .join(',')})`\n  }\n\n  return result\n}\n\ntype FindTypeDependenciesErrorType = ErrorType\n\nfunction findTypeDependencies(\n  {\n    primaryType: primaryType_,\n    types,\n  }: {\n    primaryType: string\n    types: Record<string, readonly MessageTypeProperty[]>\n  },\n  results: Set<string> = new Set(),\n): Set<string> {\n  const match = primaryType_.match(/^\\w*/u)\n  const primaryType = match?.[0]!\n  if (results.has(primaryType) || types[primaryType] === undefined) {\n    return results\n  }\n\n  results.add(primaryType)\n\n  for (const field of types[primaryType]) {\n    findTypeDependencies({ primaryType: field.type, types }, results)\n  }\n  return results\n}\n\ntype EncodeFieldErrorType =\n  | Keccak256ErrorType\n  | EncodeAbiParametersErrorType\n  | ToHexErrorType\n  | ErrorType\n\nfunction encodeField({\n  types,\n  name,\n  type,\n  value,\n}: {\n  types: Record<string, readonly MessageTypeProperty[]>\n  name: string\n  type: string\n  value: any\n}): [type: AbiParameter, value: any] {\n  if (types[type] !== undefined) {\n    return [\n      { type: 'bytes32' },\n      keccak256(encodeData({ data: value, primaryType: type, types })),\n    ]\n  }\n\n  if (type === 'bytes') {\n    const prepend = value.length % 2 ? '0' : ''\n    value = `0x${prepend + value.slice(2)}`\n    return [{ type: 'bytes32' }, keccak256(value)]\n  }\n\n  if (type === 'string') return [{ type: 'bytes32' }, keccak256(toHex(value))]\n\n  if (type.lastIndexOf(']') === type.length - 1) {\n    const parsedType = type.slice(0, type.lastIndexOf('['))\n    const typeValuePairs = (value as [AbiParameter, any][]).map((item) =>\n      encodeField({\n        name,\n        type: parsedType,\n        types,\n        value: item,\n      }),\n    )\n    return [\n      { type: 'bytes32' },\n      keccak256(\n        encodeAbiParameters(\n          typeValuePairs.map(([t]) => t),\n          typeValuePairs.map(([, v]) => v),\n        ),\n      ),\n    ]\n  }\n\n  return [{ type }, value]\n}\n","export const presignMessagePrefix = '\\x19Ethereum Signed Message:\\n'\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex, SignableMessage } from '../../types/misc.js'\nimport { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'\nimport { toPrefixedMessage } from './toPrefixedMessage.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type HashMessageReturnType<to extends To> =\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type HashMessageErrorType = Keccak256ErrorType | ErrorType\n\nexport function hashMessage<to extends To = 'hex'>(\n  message: SignableMessage,\n  to_?: to | undefined,\n): HashMessageReturnType<to> {\n  return keccak256(toPrefixedMessage(message), to_)\n}\n","import { presignMessagePrefix } from '../../constants/strings.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex, SignableMessage } from '../../types/misc.js'\nimport { type ConcatErrorType, concat } from '../data/concat.js'\nimport { size } from '../data/size.js'\nimport {\n  type BytesToHexErrorType,\n  bytesToHex,\n  type StringToHexErrorType,\n  stringToHex,\n} from '../encoding/toHex.js'\n\nexport type ToPrefixedMessageErrorType =\n  | ConcatErrorType\n  | StringToHexErrorType\n  | BytesToHexErrorType\n  | ErrorType\n\nexport function toPrefixedMessage(message_: SignableMessage): Hex {\n  const message = (() => {\n    if (typeof message_ === 'string') return stringToHex(message_)\n    if (typeof message_.raw === 'string') return message_.raw\n    return bytesToHex(message_.raw)\n  })()\n  const prefix = stringToHex(`${presignMessagePrefix}${size(message)}`)\n  return concat([prefix, message])\n}\n","import type { Abi, AbiParameter, Address } from 'abitype'\n\nimport {\n  AbiItemAmbiguityError,\n  type AbiItemAmbiguityErrorType,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  AbiItem,\n  AbiItemArgs,\n  AbiItemName,\n  ExtractAbiItemForArgs,\n  Widen,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { UnionEvaluate } from '../../types/utils.js'\nimport { type IsHexErrorType, isHex } from '../../utils/data/isHex.js'\nimport { type IsAddressErrorType, isAddress } from '../address/isAddress.js'\nimport { toEventSelector } from '../hash/toEventSelector.js'\nimport {\n  type ToFunctionSelectorErrorType,\n  toFunctionSelector,\n} from '../hash/toFunctionSelector.js'\n\nexport type GetAbiItemParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  name extends AbiItemName<abi> = AbiItemName<abi>,\n  args extends AbiItemArgs<abi, name> | undefined = AbiItemArgs<abi, name>,\n  ///\n  allArgs = AbiItemArgs<abi, name>,\n  allNames = AbiItemName<abi>,\n> = {\n  abi: abi\n  name:\n    | allNames // show all options\n    | (name extends allNames ? name : never) // infer value\n    | Hex // function selector\n} & UnionEvaluate<\n  readonly [] extends allArgs\n    ? {\n        args?:\n          | allArgs // show all options\n          // infer value, widen inferred value of `args` conditionally to match `allArgs`\n          | (abi extends Abi\n              ? args extends allArgs\n                ? Widen<args>\n                : never\n              : never)\n          | undefined\n      }\n    : {\n        args?:\n          | allArgs // show all options\n          | (Widen<args> & (args extends allArgs ? unknown : never)) // infer value, widen inferred value of `args` match `allArgs` (e.g. avoid union `args: readonly [123n] | readonly [bigint]`)\n          | undefined\n      }\n>\n\nexport type GetAbiItemErrorType =\n  | IsArgOfTypeErrorType\n  | IsHexErrorType\n  | ToFunctionSelectorErrorType\n  | AbiItemAmbiguityErrorType\n  | ErrorType\n\nexport type GetAbiItemReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  name extends AbiItemName<abi> = AbiItemName<abi>,\n  args extends AbiItemArgs<abi, name> | undefined = AbiItemArgs<abi, name>,\n> = abi extends Abi\n  ? Abi extends abi\n    ? AbiItem | undefined\n    : ExtractAbiItemForArgs<\n        abi,\n        name,\n        args extends AbiItemArgs<abi, name> ? args : AbiItemArgs<abi, name>\n      >\n  : AbiItem | undefined\n\nexport function getAbiItem<\n  const abi extends Abi | readonly unknown[],\n  name extends AbiItemName<abi>,\n  const args extends AbiItemArgs<abi, name> | undefined = undefined,\n>(\n  parameters: GetAbiItemParameters<abi, name, args>,\n): GetAbiItemReturnType<abi, name, args> {\n  const { abi, args = [], name } = parameters as unknown as GetAbiItemParameters\n\n  const isSelector = isHex(name, { strict: false })\n  const abiItems = (abi as Abi).filter((abiItem) => {\n    if (isSelector) {\n      if (abiItem.type === 'function')\n        return toFunctionSelector(abiItem) === name\n      if (abiItem.type === 'event') return toEventSelector(abiItem) === name\n      return false\n    }\n    return 'name' in abiItem && abiItem.name === name\n  })\n\n  if (abiItems.length === 0)\n    return undefined as GetAbiItemReturnType<abi, name, args>\n  if (abiItems.length === 1)\n    return abiItems[0] as GetAbiItemReturnType<abi, name, args>\n\n  let matchedAbiItem: AbiItem | undefined\n  for (const abiItem of abiItems) {\n    if (!('inputs' in abiItem)) continue\n    if (!args || args.length === 0) {\n      if (!abiItem.inputs || abiItem.inputs.length === 0)\n        return abiItem as GetAbiItemReturnType<abi, name, args>\n      continue\n    }\n    if (!abiItem.inputs) continue\n    if (abiItem.inputs.length === 0) continue\n    if (abiItem.inputs.length !== args.length) continue\n    const matched = args.every((arg, index) => {\n      const abiParameter = 'inputs' in abiItem && abiItem.inputs![index]\n      if (!abiParameter) return false\n      return isArgOfType(arg, abiParameter)\n    })\n    if (matched) {\n      // Check for ambiguity against already matched parameters (e.g. `address` vs `bytes20`).\n      if (\n        matchedAbiItem &&\n        'inputs' in matchedAbiItem &&\n        matchedAbiItem.inputs\n      ) {\n        const ambiguousTypes = getAmbiguousTypes(\n          abiItem.inputs,\n          matchedAbiItem.inputs,\n          args as readonly unknown[],\n        )\n        if (ambiguousTypes)\n          throw new AbiItemAmbiguityError(\n            {\n              abiItem,\n              type: ambiguousTypes[0],\n            },\n            {\n              abiItem: matchedAbiItem,\n              type: ambiguousTypes[1],\n            },\n          )\n      }\n\n      matchedAbiItem = abiItem\n    }\n  }\n\n  if (matchedAbiItem)\n    return matchedAbiItem as GetAbiItemReturnType<abi, name, args>\n  return abiItems[0] as GetAbiItemReturnType<abi, name, args>\n}\n\ntype IsArgOfTypeErrorType = IsAddressErrorType | ErrorType\n\n/** @internal */\nexport function isArgOfType(arg: unknown, abiParameter: AbiParameter): boolean {\n  const argType = typeof arg\n  const abiParameterType = abiParameter.type\n  switch (abiParameterType) {\n    case 'address':\n      return isAddress(arg as Address, { strict: false })\n    case 'bool':\n      return argType === 'boolean'\n    case 'function':\n      return argType === 'string'\n    case 'string':\n      return argType === 'string'\n    default: {\n      if (abiParameterType === 'tuple' && 'components' in abiParameter)\n        return Object.values(abiParameter.components).every(\n          (component, index) => {\n            return isArgOfType(\n              Object.values(arg as unknown[] | Record<string, unknown>)[index],\n              component as AbiParameter,\n            )\n          },\n        )\n\n      // `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n      // https://regexr.com/6v8hp\n      if (\n        /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(\n          abiParameterType,\n        )\n      )\n        return argType === 'number' || argType === 'bigint'\n\n      // `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n      // https://regexr.com/6va55\n      if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))\n        return argType === 'string' || arg instanceof Uint8Array\n\n      // fixed-length (`<type>[M]`) and dynamic (`<type>[]`) arrays\n      // https://regexr.com/6va6i\n      if (/[a-z]+[1-9]{0,3}(\\[[0-9]{0,}\\])+$/.test(abiParameterType)) {\n        return (\n          Array.isArray(arg) &&\n          arg.every((x: unknown) =>\n            isArgOfType(x, {\n              ...abiParameter,\n              // Pop off `[]` or `[M]` from end of type\n              type: abiParameterType.replace(/(\\[[0-9]{0,}\\])$/, ''),\n            } as AbiParameter),\n          )\n        )\n      }\n\n      return false\n    }\n  }\n}\n\n/** @internal */\nexport function getAmbiguousTypes(\n  sourceParameters: readonly AbiParameter[],\n  targetParameters: readonly AbiParameter[],\n  args: AbiItemArgs,\n): AbiParameter['type'][] | undefined {\n  for (const parameterIndex in sourceParameters) {\n    const sourceParameter = sourceParameters[parameterIndex]\n    const targetParameter = targetParameters[parameterIndex]\n\n    if (\n      sourceParameter.type === 'tuple' &&\n      targetParameter.type === 'tuple' &&\n      'components' in sourceParameter &&\n      'components' in targetParameter\n    )\n      return getAmbiguousTypes(\n        sourceParameter.components,\n        targetParameter.components,\n        (args as any)[parameterIndex],\n      )\n\n    const types = [sourceParameter.type, targetParameter.type]\n\n    const ambiguous = (() => {\n      if (types.includes('address') && types.includes('bytes20')) return true\n      if (types.includes('address') && types.includes('string'))\n        return isAddress(args[parameterIndex] as Address, { strict: false })\n      if (types.includes('address') && types.includes('bytes'))\n        return isAddress(args[parameterIndex] as Address, { strict: false })\n      return false\n    })()\n\n    if (ambiguous) return types\n  }\n\n  return\n}\n","import type { AbiFunction } from 'abitype'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport { type SliceErrorType, slice } from '../data/slice.js'\nimport {\n  type ToSignatureHashErrorType,\n  toSignatureHash,\n} from './toSignatureHash.js'\n\nexport type ToFunctionSelectorErrorType =\n  | ToSignatureHashErrorType\n  | SliceErrorType\n  | ErrorType\n\n/**\n * Returns the function selector for a given function definition.\n *\n * @example\n * const selector = toFunctionSelector('function ownerOf(uint256 tokenId)')\n * // 0x6352211e\n */\nexport const toFunctionSelector = (fn: string | AbiFunction) =>\n  slice(toSignatureHash(fn), 0, 4)\n","// TODO: This looks cool. Need to check the performance of `new RegExp` versus defined inline though.\n// https://twitter.com/GabrielVergnaud/status/1622906834343366657\nexport function execTyped<type>(regex: RegExp, string: string) {\n  const match = regex.exec(string)\n  return match?.groups as type | undefined\n}\n\n// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n// https://regexr.com/6va55\nexport const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/\n\n// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n// https://regexr.com/6v8hp\nexport const integerRegex =\n  /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/\n\nexport const isTupleRegex = /^\\(.+?\\).*?$/\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\n\nexport type ConcatReturnType<value extends Hex | ByteArray> = value extends Hex\n  ? Hex\n  : ByteArray\n\nexport type ConcatErrorType =\n  | ConcatBytesErrorType\n  | ConcatHexErrorType\n  | ErrorType\n\nexport function concat<value extends Hex | ByteArray>(\n  values: readonly value[],\n): ConcatReturnType<value> {\n  if (typeof values[0] === 'string')\n    return concatHex(values as readonly Hex[]) as ConcatReturnType<value>\n  return concatBytes(values as readonly ByteArray[]) as ConcatReturnType<value>\n}\n\nexport type ConcatBytesErrorType = ErrorType\n\nexport function concatBytes(values: readonly ByteArray[]): ByteArray {\n  let length = 0\n  for (const arr of values) {\n    length += arr.length\n  }\n  const result = new Uint8Array(length)\n  let offset = 0\n  for (const arr of values) {\n    result.set(arr, offset)\n    offset += arr.length\n  }\n  return result\n}\n\nexport type ConcatHexErrorType = ErrorType\n\nexport function concatHex(values: readonly Hex[]): Hex {\n  return `0x${(values as Hex[]).reduce(\n    (acc, x) => acc + x.replace('0x', ''),\n    '',\n  )}`\n}\n","import {\n  SliceOffsetOutOfBoundsError,\n  type SliceOffsetOutOfBoundsErrorType,\n} from '../../errors/data.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\n\nimport { type IsHexErrorType, isHex } from './isHex.js'\nimport { type SizeErrorType, size } from './size.js'\n\nexport type SliceReturnType<value extends ByteArray | Hex> = value extends Hex\n  ? Hex\n  : ByteArray\n\nexport type SliceErrorType =\n  | IsHexErrorType\n  | SliceBytesErrorType\n  | SliceHexErrorType\n  | ErrorType\n\n/**\n * @description Returns a section of the hex or byte array given a start/end bytes offset.\n *\n * @param value The hex or byte array to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function slice<value extends ByteArray | Hex>(\n  value: value,\n  start?: number | undefined,\n  end?: number | undefined,\n  { strict }: { strict?: boolean | undefined } = {},\n): SliceReturnType<value> {\n  if (isHex(value, { strict: false }))\n    return sliceHex(value as Hex, start, end, {\n      strict,\n    }) as SliceReturnType<value>\n  return sliceBytes(value as ByteArray, start, end, {\n    strict,\n  }) as SliceReturnType<value>\n}\n\nexport type AssertStartOffsetErrorType =\n  | SliceOffsetOutOfBoundsErrorType\n  | SizeErrorType\n  | ErrorType\n\nfunction assertStartOffset(value: Hex | ByteArray, start?: number | undefined) {\n  if (typeof start === 'number' && start > 0 && start > size(value) - 1)\n    throw new SliceOffsetOutOfBoundsError({\n      offset: start,\n      position: 'start',\n      size: size(value),\n    })\n}\n\nexport type AssertEndOffsetErrorType =\n  | SliceOffsetOutOfBoundsErrorType\n  | SizeErrorType\n  | ErrorType\n\nfunction assertEndOffset(\n  value: Hex | ByteArray,\n  start?: number | undefined,\n  end?: number | undefined,\n) {\n  if (\n    typeof start === 'number' &&\n    typeof end === 'number' &&\n    size(value) !== end - start\n  ) {\n    throw new SliceOffsetOutOfBoundsError({\n      offset: end,\n      position: 'end',\n      size: size(value),\n    })\n  }\n}\n\nexport type SliceBytesErrorType =\n  | AssertStartOffsetErrorType\n  | AssertEndOffsetErrorType\n  | ErrorType\n\n/**\n * @description Returns a section of the byte array given a start/end bytes offset.\n *\n * @param value The byte array to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function sliceBytes(\n  value_: ByteArray,\n  start?: number | undefined,\n  end?: number | undefined,\n  { strict }: { strict?: boolean | undefined } = {},\n): ByteArray {\n  assertStartOffset(value_, start)\n  const value = value_.slice(start, end)\n  if (strict) assertEndOffset(value, start, end)\n  return value\n}\n\nexport type SliceHexErrorType =\n  | AssertStartOffsetErrorType\n  | AssertEndOffsetErrorType\n  | ErrorType\n\n/**\n * @description Returns a section of the hex value given a start/end bytes offset.\n *\n * @param value The hex value to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function sliceHex(\n  value_: Hex,\n  start?: number | undefined,\n  end?: number | undefined,\n  { strict }: { strict?: boolean | undefined } = {},\n): Hex {\n  assertStartOffset(value_, start)\n  const value = `0x${value_\n    .replace('0x', '')\n    .slice((start ?? 0) * 2, (end ?? value_.length) * 2)}` as const\n  if (strict) assertEndOffset(value, start, end)\n  return value\n}\n","import type { AbiParameter } from 'abitype'\n\nimport {\n  InvalidDefinitionTypeError,\n  type InvalidDefinitionTypeErrorType,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { AbiItem } from '../../types/contract.js'\n\nexport type FormatAbiItemErrorType =\n  | FormatAbiParamsErrorType\n  | InvalidDefinitionTypeErrorType\n  | ErrorType\n\nexport function formatAbiItem(\n  abiItem: AbiItem,\n  { includeName = false }: { includeName?: boolean | undefined } = {},\n) {\n  if (\n    abiItem.type !== 'function' &&\n    abiItem.type !== 'event' &&\n    abiItem.type !== 'error'\n  )\n    throw new InvalidDefinitionTypeError(abiItem.type)\n\n  return `${abiItem.name}(${formatAbiParams(abiItem.inputs, { includeName })})`\n}\n\nexport type FormatAbiParamsErrorType = ErrorType\n\nexport function formatAbiParams(\n  params: readonly AbiParameter[] | undefined,\n  { includeName = false }: { includeName?: boolean | undefined } = {},\n): string {\n  if (!params) return ''\n  return params\n    .map((param) => formatAbiParam(param, { includeName }))\n    .join(includeName ? ', ' : ',')\n}\n\nexport type FormatAbiParamErrorType = ErrorType\n\nfunction formatAbiParam(\n  param: AbiParameter,\n  { includeName }: { includeName: boolean },\n): string {\n  if (param.type.startsWith('tuple')) {\n    return `(${formatAbiParams(\n      (param as unknown as { components: AbiParameter[] }).components,\n      { includeName },\n    )})${param.type.slice('tuple'.length)}`\n  }\n  return param.type + (includeName && param.name ? ` ${param.name}` : '')\n}\n","import type { Abi, AbiEvent, AbiParameter } from 'abitype'\n\nimport type { Hex } from '../types/misc.js'\nimport { formatAbiItem, formatAbiParams } from '../utils/abi/formatAbiItem.js'\nimport { size } from '../utils/data/size.js'\n\nimport { BaseError } from './base.js'\n\nexport type AbiConstructorNotFoundErrorType = AbiConstructorNotFoundError & {\n  name: 'AbiConstructorNotFoundError'\n}\nexport class AbiConstructorNotFoundError extends BaseError {\n  constructor({ docsPath }: { docsPath: string }) {\n    super(\n      [\n        'A constructor was not found on the ABI.',\n        'Make sure you are using the correct ABI and that the constructor exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiConstructorNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiConstructorParamsNotFoundErrorType =\n  AbiConstructorParamsNotFoundError & {\n    name: 'AbiConstructorParamsNotFoundError'\n  }\n\nexport class AbiConstructorParamsNotFoundError extends BaseError {\n  constructor({ docsPath }: { docsPath: string }) {\n    super(\n      [\n        'Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.',\n        'Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiConstructorParamsNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiDecodingDataSizeInvalidErrorType =\n  AbiDecodingDataSizeInvalidError & {\n    name: 'AbiDecodingDataSizeInvalidError'\n  }\nexport class AbiDecodingDataSizeInvalidError extends BaseError {\n  constructor({ data, size }: { data: Hex; size: number }) {\n    super(\n      [\n        `Data size of ${size} bytes is invalid.`,\n        'Size must be in increments of 32 bytes (size % 32 === 0).',\n      ].join('\\n'),\n      {\n        metaMessages: [`Data: ${data} (${size} bytes)`],\n        name: 'AbiDecodingDataSizeInvalidError',\n      },\n    )\n  }\n}\n\nexport type AbiDecodingDataSizeTooSmallErrorType =\n  AbiDecodingDataSizeTooSmallError & {\n    name: 'AbiDecodingDataSizeTooSmallError'\n  }\nexport class AbiDecodingDataSizeTooSmallError extends BaseError {\n  data: Hex\n  params: readonly AbiParameter[]\n  size: number\n\n  constructor({\n    data,\n    params,\n    size,\n  }: { data: Hex; params: readonly AbiParameter[]; size: number }) {\n    super(\n      [`Data size of ${size} bytes is too small for given parameters.`].join(\n        '\\n',\n      ),\n      {\n        metaMessages: [\n          `Params: (${formatAbiParams(params, { includeName: true })})`,\n          `Data:   ${data} (${size} bytes)`,\n        ],\n        name: 'AbiDecodingDataSizeTooSmallError',\n      },\n    )\n\n    this.data = data\n    this.params = params\n    this.size = size\n  }\n}\n\nexport type AbiDecodingZeroDataErrorType = AbiDecodingZeroDataError & {\n  name: 'AbiDecodingZeroDataError'\n}\nexport class AbiDecodingZeroDataError extends BaseError {\n  constructor() {\n    super('Cannot decode zero data (\"0x\") with ABI parameters.', {\n      name: 'AbiDecodingZeroDataError',\n    })\n  }\n}\n\nexport type AbiEncodingArrayLengthMismatchErrorType =\n  AbiEncodingArrayLengthMismatchError & {\n    name: 'AbiEncodingArrayLengthMismatchError'\n  }\nexport class AbiEncodingArrayLengthMismatchError extends BaseError {\n  constructor({\n    expectedLength,\n    givenLength,\n    type,\n  }: { expectedLength: number; givenLength: number; type: string }) {\n    super(\n      [\n        `ABI encoding array length mismatch for type ${type}.`,\n        `Expected length: ${expectedLength}`,\n        `Given length: ${givenLength}`,\n      ].join('\\n'),\n      { name: 'AbiEncodingArrayLengthMismatchError' },\n    )\n  }\n}\n\nexport type AbiEncodingBytesSizeMismatchErrorType =\n  AbiEncodingBytesSizeMismatchError & {\n    name: 'AbiEncodingBytesSizeMismatchError'\n  }\nexport class AbiEncodingBytesSizeMismatchError extends BaseError {\n  constructor({ expectedSize, value }: { expectedSize: number; value: Hex }) {\n    super(\n      `Size of bytes \"${value}\" (bytes${size(\n        value,\n      )}) does not match expected size (bytes${expectedSize}).`,\n      { name: 'AbiEncodingBytesSizeMismatchError' },\n    )\n  }\n}\n\nexport type AbiEncodingLengthMismatchErrorType =\n  AbiEncodingLengthMismatchError & {\n    name: 'AbiEncodingLengthMismatchError'\n  }\nexport class AbiEncodingLengthMismatchError extends BaseError {\n  constructor({\n    expectedLength,\n    givenLength,\n  }: { expectedLength: number; givenLength: number }) {\n    super(\n      [\n        'ABI encoding params/values length mismatch.',\n        `Expected length (params): ${expectedLength}`,\n        `Given length (values): ${givenLength}`,\n      ].join('\\n'),\n      { name: 'AbiEncodingLengthMismatchError' },\n    )\n  }\n}\n\nexport type AbiErrorInputsNotFoundErrorType = AbiErrorInputsNotFoundError & {\n  name: 'AbiErrorInputsNotFoundError'\n}\nexport class AbiErrorInputsNotFoundError extends BaseError {\n  constructor(errorName: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Arguments (\\`args\\`) were provided to \"${errorName}\", but \"${errorName}\" on the ABI does not contain any parameters (\\`inputs\\`).`,\n        'Cannot encode error result without knowing what the parameter types are.',\n        'Make sure you are using the correct ABI and that the inputs exist on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiErrorInputsNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiErrorNotFoundErrorType = AbiErrorNotFoundError & {\n  name: 'AbiErrorNotFoundError'\n}\nexport class AbiErrorNotFoundError extends BaseError {\n  constructor(\n    errorName?: string | undefined,\n    { docsPath }: { docsPath?: string | undefined } = {},\n  ) {\n    super(\n      [\n        `Error ${errorName ? `\"${errorName}\" ` : ''}not found on ABI.`,\n        'Make sure you are using the correct ABI and that the error exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiErrorNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiErrorSignatureNotFoundErrorType =\n  AbiErrorSignatureNotFoundError & {\n    name: 'AbiErrorSignatureNotFoundError'\n  }\nexport class AbiErrorSignatureNotFoundError extends BaseError {\n  signature: Hex\n\n  constructor(signature: Hex, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Encoded error signature \"${signature}\" not found on ABI.`,\n        'Make sure you are using the correct ABI and that the error exists on it.',\n        `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`,\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiErrorSignatureNotFoundError',\n      },\n    )\n    this.signature = signature\n  }\n}\n\nexport type AbiEventSignatureEmptyTopicsErrorType =\n  AbiEventSignatureEmptyTopicsError & {\n    name: 'AbiEventSignatureEmptyTopicsError'\n  }\nexport class AbiEventSignatureEmptyTopicsError extends BaseError {\n  constructor({ docsPath }: { docsPath: string }) {\n    super('Cannot extract event signature from empty topics.', {\n      docsPath,\n      name: 'AbiEventSignatureEmptyTopicsError',\n    })\n  }\n}\n\nexport type AbiEventSignatureNotFoundErrorType =\n  AbiEventSignatureNotFoundError & {\n    name: 'AbiEventSignatureNotFoundError'\n  }\nexport class AbiEventSignatureNotFoundError extends BaseError {\n  constructor(signature: Hex, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Encoded event signature \"${signature}\" not found on ABI.`,\n        'Make sure you are using the correct ABI and that the event exists on it.',\n        `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`,\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiEventSignatureNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiEventNotFoundErrorType = AbiEventNotFoundError & {\n  name: 'AbiEventNotFoundError'\n}\nexport class AbiEventNotFoundError extends BaseError {\n  constructor(\n    eventName?: string | undefined,\n    { docsPath }: { docsPath?: string | undefined } = {},\n  ) {\n    super(\n      [\n        `Event ${eventName ? `\"${eventName}\" ` : ''}not found on ABI.`,\n        'Make sure you are using the correct ABI and that the event exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiEventNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiFunctionNotFoundErrorType = AbiFunctionNotFoundError & {\n  name: 'AbiFunctionNotFoundError'\n}\nexport class AbiFunctionNotFoundError extends BaseError {\n  constructor(\n    functionName?: string | undefined,\n    { docsPath }: { docsPath?: string | undefined } = {},\n  ) {\n    super(\n      [\n        `Function ${functionName ? `\"${functionName}\" ` : ''}not found on ABI.`,\n        'Make sure you are using the correct ABI and that the function exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiFunctionNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiFunctionOutputsNotFoundErrorType =\n  AbiFunctionOutputsNotFoundError & {\n    name: 'AbiFunctionOutputsNotFoundError'\n  }\nexport class AbiFunctionOutputsNotFoundError extends BaseError {\n  constructor(functionName: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Function \"${functionName}\" does not contain any \\`outputs\\` on ABI.`,\n        'Cannot decode function result without knowing what the parameter types are.',\n        'Make sure you are using the correct ABI and that the function exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiFunctionOutputsNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiFunctionSignatureNotFoundErrorType =\n  AbiFunctionSignatureNotFoundError & {\n    name: 'AbiFunctionSignatureNotFoundError'\n  }\nexport class AbiFunctionSignatureNotFoundError extends BaseError {\n  constructor(signature: Hex, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Encoded function signature \"${signature}\" not found on ABI.`,\n        'Make sure you are using the correct ABI and that the function exists on it.',\n        `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`,\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiFunctionSignatureNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiItemAmbiguityErrorType = AbiItemAmbiguityError & {\n  name: 'AbiItemAmbiguityError'\n}\nexport class AbiItemAmbiguityError extends BaseError {\n  constructor(\n    x: { abiItem: Abi[number]; type: string },\n    y: { abiItem: Abi[number]; type: string },\n  ) {\n    super('Found ambiguous types in overloaded ABI items.', {\n      metaMessages: [\n        `\\`${x.type}\\` in \\`${formatAbiItem(x.abiItem)}\\`, and`,\n        `\\`${y.type}\\` in \\`${formatAbiItem(y.abiItem)}\\``,\n        '',\n        'These types encode differently and cannot be distinguished at runtime.',\n        'Remove one of the ambiguous items in the ABI.',\n      ],\n      name: 'AbiItemAmbiguityError',\n    })\n  }\n}\n\nexport type BytesSizeMismatchErrorType = BytesSizeMismatchError & {\n  name: 'BytesSizeMismatchError'\n}\nexport class BytesSizeMismatchError extends BaseError {\n  constructor({\n    expectedSize,\n    givenSize,\n  }: { expectedSize: number; givenSize: number }) {\n    super(`Expected bytes${expectedSize}, got bytes${givenSize}.`, {\n      name: 'BytesSizeMismatchError',\n    })\n  }\n}\n\nexport type DecodeLogDataMismatchErrorType = DecodeLogDataMismatch & {\n  name: 'DecodeLogDataMismatch'\n}\nexport class DecodeLogDataMismatch extends BaseError {\n  abiItem: AbiEvent\n  data: Hex\n  params: readonly AbiParameter[]\n  size: number\n\n  constructor({\n    abiItem,\n    data,\n    params,\n    size,\n  }: {\n    abiItem: AbiEvent\n    data: Hex\n    params: readonly AbiParameter[]\n    size: number\n  }) {\n    super(\n      [\n        `Data size of ${size} bytes is too small for non-indexed event parameters.`,\n      ].join('\\n'),\n      {\n        metaMessages: [\n          `Params: (${formatAbiParams(params, { includeName: true })})`,\n          `Data:   ${data} (${size} bytes)`,\n        ],\n        name: 'DecodeLogDataMismatch',\n      },\n    )\n\n    this.abiItem = abiItem\n    this.data = data\n    this.params = params\n    this.size = size\n  }\n}\n\nexport type DecodeLogTopicsMismatchErrorType = DecodeLogTopicsMismatch & {\n  name: 'DecodeLogTopicsMismatch'\n}\nexport class DecodeLogTopicsMismatch extends BaseError {\n  abiItem: AbiEvent\n\n  constructor({\n    abiItem,\n    param,\n  }: {\n    abiItem: AbiEvent\n    param: AbiParameter & { indexed: boolean }\n  }) {\n    super(\n      [\n        `Expected a topic for indexed event parameter${\n          param.name ? ` \"${param.name}\"` : ''\n        } on event \"${formatAbiItem(abiItem, { includeName: true })}\".`,\n      ].join('\\n'),\n      { name: 'DecodeLogTopicsMismatch' },\n    )\n\n    this.abiItem = abiItem\n  }\n}\n\nexport type InvalidAbiEncodingTypeErrorType = InvalidAbiEncodingTypeError & {\n  name: 'InvalidAbiEncodingTypeError'\n}\nexport class InvalidAbiEncodingTypeError extends BaseError {\n  constructor(type: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Type \"${type}\" is not a valid encoding type.`,\n        'Please provide a valid ABI type.',\n      ].join('\\n'),\n      { docsPath, name: 'InvalidAbiEncodingType' },\n    )\n  }\n}\n\nexport type InvalidAbiDecodingTypeErrorType = InvalidAbiDecodingTypeError & {\n  name: 'InvalidAbiDecodingTypeError'\n}\nexport class InvalidAbiDecodingTypeError extends BaseError {\n  constructor(type: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Type \"${type}\" is not a valid decoding type.`,\n        'Please provide a valid ABI type.',\n      ].join('\\n'),\n      { docsPath, name: 'InvalidAbiDecodingType' },\n    )\n  }\n}\n\nexport type InvalidArrayErrorType = InvalidArrayError & {\n  name: 'InvalidArrayError'\n}\nexport class InvalidArrayError extends BaseError {\n  constructor(value: unknown) {\n    super([`Value \"${value}\" is not a valid array.`].join('\\n'), {\n      name: 'InvalidArrayError',\n    })\n  }\n}\n\nexport type InvalidDefinitionTypeErrorType = InvalidDefinitionTypeError & {\n  name: 'InvalidDefinitionTypeError'\n}\nexport class InvalidDefinitionTypeError extends BaseError {\n  constructor(type: string) {\n    super(\n      [\n        `\"${type}\" is not a valid definition type.`,\n        'Valid types: \"function\", \"event\", \"error\"',\n      ].join('\\n'),\n      { name: 'InvalidDefinitionTypeError' },\n    )\n  }\n}\n\nexport type UnsupportedPackedAbiTypeErrorType = UnsupportedPackedAbiType & {\n  name: 'UnsupportedPackedAbiType'\n}\nexport class UnsupportedPackedAbiType extends BaseError {\n  constructor(type: unknown) {\n    super(`Type \"${type}\" is not supported for packed encoding.`, {\n      name: 'UnsupportedPackedAbiType',\n    })\n  }\n}\n","import type { AbiEventParameter, AbiParameter } from '../abi.js'\nimport { execTyped } from '../regex.js'\nimport type { IsNarrowable, Join } from '../types.js'\nimport type { AssertName } from './types/signatures.js'\n\n/**\n * Formats {@link AbiParameter} to human-readable ABI parameter.\n *\n * @param abiParameter - ABI parameter\n * @returns Human-readable ABI parameter\n *\n * @example\n * type Result = FormatAbiParameter<{ type: 'address'; name: 'from'; }>\n * //   ^? type Result = 'address from'\n */\nexport type FormatAbiParameter<\n  abiParameter extends AbiParameter | AbiEventParameter,\n> = abiParameter extends {\n  name?: infer name extends string\n  type: `tuple${infer array}`\n  components: infer components extends readonly AbiParameter[]\n  indexed?: infer indexed extends boolean\n}\n  ? FormatAbiParameter<\n      {\n        type: `(${Join<\n          {\n            [key in keyof components]: FormatAbiParameter<\n              {\n                type: components[key]['type']\n              } & (IsNarrowable<components[key]['name'], string> extends true\n                ? { name: components[key]['name'] }\n                : unknown) &\n                (components[key] extends { components: readonly AbiParameter[] }\n                  ? { components: components[key]['components'] }\n                  : unknown)\n            >\n          },\n          ', '\n        >})${array}`\n      } & (IsNarrowable<name, string> extends true ? { name: name } : unknown) &\n        (IsNarrowable<indexed, boolean> extends true\n          ? { indexed: indexed }\n          : unknown)\n    >\n  : `${abiParameter['type']}${abiParameter extends { indexed: true }\n      ? ' indexed'\n      : ''}${abiParameter['name'] extends infer name extends string\n      ? name extends ''\n        ? ''\n        : ` ${AssertName<name>}`\n      : ''}`\n\n// https://regexr.com/7f7rv\nconst tupleRegex = /^tuple(?<array>(\\[(\\d*)\\])*)$/\n\n/**\n * Formats {@link AbiParameter} to human-readable ABI parameter.\n *\n * @param abiParameter - ABI parameter\n * @returns Human-readable ABI parameter\n *\n * @example\n * const result = formatAbiParameter({ type: 'address', name: 'from' })\n * //    ^? const result: 'address from'\n */\nexport function formatAbiParameter<\n  const abiParameter extends AbiParameter | AbiEventParameter,\n>(abiParameter: abiParameter): FormatAbiParameter<abiParameter> {\n  type Result = FormatAbiParameter<abiParameter>\n\n  let type = abiParameter.type\n  if (tupleRegex.test(abiParameter.type) && 'components' in abiParameter) {\n    type = '('\n    const length = abiParameter.components.length as number\n    for (let i = 0; i < length; i++) {\n      const component = abiParameter.components[i]!\n      type += formatAbiParameter(component)\n      if (i < length - 1) type += ', '\n    }\n    const result = execTyped<{ array?: string }>(tupleRegex, abiParameter.type)\n    type += `)${result?.array ?? ''}`\n    return formatAbiParameter({\n      ...abiParameter,\n      type,\n    }) as Result\n  }\n  // Add `indexed` to type if in `abiParameter`\n  if ('indexed' in abiParameter && abiParameter.indexed)\n    type = `${type} indexed`\n  // Return human-readable ABI parameter\n  if (abiParameter.name) return `${type} ${abiParameter.name}` as Result\n  return type as Result\n}\n","import type { AbiEventParameter, AbiParameter } from '../abi.js'\nimport type { Join } from '../types.js'\nimport {\n  type FormatAbiParameter,\n  formatAbiParameter,\n} from './formatAbiParameter.js'\n\n/**\n * Formats {@link AbiParameter}s to human-readable ABI parameter.\n *\n * @param abiParameters - ABI parameters\n * @returns Human-readable ABI parameters\n *\n * @example\n * type Result = FormatAbiParameters<[\n *   // ^? type Result = 'address from, uint256 tokenId'\n *   { type: 'address'; name: 'from'; },\n *   { type: 'uint256'; name: 'tokenId'; },\n * ]>\n */\nexport type FormatAbiParameters<\n  abiParameters extends readonly [\n    AbiParameter | AbiEventParameter,\n    ...(readonly (AbiParameter | AbiEventParameter)[]),\n  ],\n> = Join<\n  {\n    [key in keyof abiParameters]: FormatAbiParameter<abiParameters[key]>\n  },\n  ', '\n>\n\n/**\n * Formats {@link AbiParameter}s to human-readable ABI parameters.\n *\n * @param abiParameters - ABI parameters\n * @returns Human-readable ABI parameters\n *\n * @example\n * const result = formatAbiParameters([\n *   //  ^? const result: 'address from, uint256 tokenId'\n *   { type: 'address', name: 'from' },\n *   { type: 'uint256', name: 'tokenId' },\n * ])\n */\nexport function formatAbiParameters<\n  const abiParameters extends readonly [\n    AbiParameter | AbiEventParameter,\n    ...(readonly (AbiParameter | AbiEventParameter)[]),\n  ],\n>(abiParameters: abiParameters): FormatAbiParameters<abiParameters> {\n  let params = ''\n  const length = abiParameters.length\n  for (let i = 0; i < length; i++) {\n    const abiParameter = abiParameters[i]!\n    params += formatAbiParameter(abiParameter)\n    if (i !== length - 1) params += ', '\n  }\n  return params as FormatAbiParameters<abiParameters>\n}\n","import type {\n  AbiParameter,\n  AbiParametersToPrimitiveTypes,\n  AbiParameterToPrimitiveType,\n} from 'abitype'\n\nimport {\n  AbiEncodingArrayLengthMismatchError,\n  type AbiEncodingArrayLengthMismatchErrorType,\n  AbiEncodingBytesSizeMismatchError,\n  type AbiEncodingBytesSizeMismatchErrorType,\n  AbiEncodingLengthMismatchError,\n  type AbiEncodingLengthMismatchErrorType,\n  InvalidAbiEncodingTypeError,\n  type InvalidAbiEncodingTypeErrorType,\n  InvalidArrayError,\n  type InvalidArrayErrorType,\n} from '../../errors/abi.js'\nimport {\n  InvalidAddressError,\n  type InvalidAddressErrorType,\n} from '../../errors/address.js'\nimport { BaseError } from '../../errors/base.js'\nimport { IntegerOutOfRangeError } from '../../errors/encoding.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport { type IsAddressErrorType, isAddress } from '../address/isAddress.js'\nimport { type ConcatErrorType, concat } from '../data/concat.js'\nimport { type PadHexErrorType, padHex } from '../data/pad.js'\nimport { type SizeErrorType, size } from '../data/size.js'\nimport { type SliceErrorType, slice } from '../data/slice.js'\nimport {\n  type BoolToHexErrorType,\n  boolToHex,\n  type NumberToHexErrorType,\n  numberToHex,\n  type StringToHexErrorType,\n  stringToHex,\n} from '../encoding/toHex.js'\nimport { integerRegex } from '../regex.js'\n\nexport type EncodeAbiParametersReturnType = Hex\n\nexport type EncodeAbiParametersErrorType =\n  | AbiEncodingLengthMismatchErrorType\n  | PrepareParamsErrorType\n  | EncodeParamsErrorType\n  | ErrorType\n\n/**\n * @description Encodes a list of primitive values into an ABI-encoded hex value.\n *\n * - Docs: https://viem.sh/docs/abi/encodeAbiParameters#encodeabiparameters\n *\n *   Generates ABI encoded data using the [ABI specification](https://docs.soliditylang.org/en/latest/abi-spec), given a set of ABI parameters (inputs/outputs) and their corresponding values.\n *\n * @param params - a set of ABI Parameters (params), that can be in the shape of the inputs or outputs attribute of an ABI Item.\n * @param values - a set of values (values) that correspond to the given params.\n * @example\n * ```typescript\n * import { encodeAbiParameters } from 'viem'\n *\n * const encodedData = encodeAbiParameters(\n *   [\n *     { name: 'x', type: 'string' },\n *     { name: 'y', type: 'uint' },\n *     { name: 'z', type: 'bool' }\n *   ],\n *   ['wagmi', 420n, true]\n * )\n * ```\n *\n * You can also pass in Human Readable parameters with the parseAbiParameters utility.\n *\n * @example\n * ```typescript\n * import { encodeAbiParameters, parseAbiParameters } from 'viem'\n *\n * const encodedData = encodeAbiParameters(\n *   parseAbiParameters('string x, uint y, bool z'),\n *   ['wagmi', 420n, true]\n * )\n * ```\n */\nexport function encodeAbiParameters<\n  const params extends readonly AbiParameter[] | readonly unknown[],\n>(\n  params: params,\n  values: params extends readonly AbiParameter[]\n    ? AbiParametersToPrimitiveTypes<params>\n    : never,\n): EncodeAbiParametersReturnType {\n  if (params.length !== values.length)\n    throw new AbiEncodingLengthMismatchError({\n      expectedLength: params.length as number,\n      givenLength: values.length as any,\n    })\n  // Prepare the parameters to determine dynamic types to encode.\n  const preparedParams = prepareParams({\n    params: params as readonly AbiParameter[],\n    values: values as any,\n  })\n  const data = encodeParams(preparedParams)\n  if (data.length === 0) return '0x'\n  return data\n}\n\n/////////////////////////////////////////////////////////////////\n\ntype PreparedParam = { dynamic: boolean; encoded: Hex }\n\ntype TupleAbiParameter = AbiParameter & { components: readonly AbiParameter[] }\ntype Tuple = AbiParameterToPrimitiveType<TupleAbiParameter>\n\ntype PrepareParamsErrorType = PrepareParamErrorType | ErrorType\n\nfunction prepareParams<const params extends readonly AbiParameter[]>({\n  params,\n  values,\n}: {\n  params: params\n  values: AbiParametersToPrimitiveTypes<params>\n}) {\n  const preparedParams: PreparedParam[] = []\n  for (let i = 0; i < params.length; i++) {\n    preparedParams.push(prepareParam({ param: params[i], value: values[i] }))\n  }\n  return preparedParams\n}\n\ntype PrepareParamErrorType =\n  | EncodeAddressErrorType\n  | EncodeArrayErrorType\n  | EncodeBytesErrorType\n  | EncodeBoolErrorType\n  | EncodeNumberErrorType\n  | EncodeStringErrorType\n  | EncodeTupleErrorType\n  | GetArrayComponentsErrorType\n  | InvalidAbiEncodingTypeErrorType\n  | ErrorType\n\nfunction prepareParam<const param extends AbiParameter>({\n  param,\n  value,\n}: {\n  param: param\n  value: AbiParameterToPrimitiveType<param>\n}): PreparedParam {\n  const arrayComponents = getArrayComponents(param.type)\n  if (arrayComponents) {\n    const [length, type] = arrayComponents\n    return encodeArray(value, { length, param: { ...param, type } })\n  }\n  if (param.type === 'tuple') {\n    return encodeTuple(value as unknown as Tuple, {\n      param: param as TupleAbiParameter,\n    })\n  }\n  if (param.type === 'address') {\n    return encodeAddress(value as unknown as Hex)\n  }\n  if (param.type === 'bool') {\n    return encodeBool(value as unknown as boolean)\n  }\n  if (param.type.startsWith('uint') || param.type.startsWith('int')) {\n    const signed = param.type.startsWith('int')\n    const [, , size = '256'] = integerRegex.exec(param.type) ?? []\n    return encodeNumber(value as unknown as number, {\n      signed,\n      size: Number(size),\n    })\n  }\n  if (param.type.startsWith('bytes')) {\n    return encodeBytes(value as unknown as Hex, { param })\n  }\n  if (param.type === 'string') {\n    return encodeString(value as unknown as string)\n  }\n  throw new InvalidAbiEncodingTypeError(param.type, {\n    docsPath: '/docs/contract/encodeAbiParameters',\n  })\n}\n\n/////////////////////////////////////////////////////////////////\n\ntype EncodeParamsErrorType = NumberToHexErrorType | SizeErrorType | ErrorType\n\nfunction encodeParams(preparedParams: PreparedParam[]): Hex {\n  // 1. Compute the size of the static part of the parameters.\n  let staticSize = 0\n  for (let i = 0; i < preparedParams.length; i++) {\n    const { dynamic, encoded } = preparedParams[i]\n    if (dynamic) staticSize += 32\n    else staticSize += size(encoded)\n  }\n\n  // 2. Split the parameters into static and dynamic parts.\n  const staticParams: Hex[] = []\n  const dynamicParams: Hex[] = []\n  let dynamicSize = 0\n  for (let i = 0; i < preparedParams.length; i++) {\n    const { dynamic, encoded } = preparedParams[i]\n    if (dynamic) {\n      staticParams.push(numberToHex(staticSize + dynamicSize, { size: 32 }))\n      dynamicParams.push(encoded)\n      dynamicSize += size(encoded)\n    } else {\n      staticParams.push(encoded)\n    }\n  }\n\n  // 3. Concatenate static and dynamic parts.\n  return concat([...staticParams, ...dynamicParams])\n}\n\n/////////////////////////////////////////////////////////////////\n\ntype EncodeAddressErrorType =\n  | InvalidAddressErrorType\n  | IsAddressErrorType\n  | ErrorType\n\nfunction encodeAddress(value: Hex): PreparedParam {\n  if (!isAddress(value)) throw new InvalidAddressError({ address: value })\n  return { dynamic: false, encoded: padHex(value.toLowerCase() as Hex) }\n}\n\ntype EncodeArrayErrorType =\n  | AbiEncodingArrayLengthMismatchErrorType\n  | ConcatErrorType\n  | EncodeParamsErrorType\n  | InvalidArrayErrorType\n  | NumberToHexErrorType\n  // TODO: Add back once circular type reference is resolved\n  // | PrepareParamErrorType\n  | ErrorType\n\nfunction encodeArray<const param extends AbiParameter>(\n  value: AbiParameterToPrimitiveType<param>,\n  {\n    length,\n    param,\n  }: {\n    length: number | null\n    param: param\n  },\n): PreparedParam {\n  const dynamic = length === null\n\n  if (!Array.isArray(value)) throw new InvalidArrayError(value)\n  if (!dynamic && value.length !== length)\n    throw new AbiEncodingArrayLengthMismatchError({\n      expectedLength: length!,\n      givenLength: value.length,\n      type: `${param.type}[${length}]`,\n    })\n\n  let dynamicChild = false\n  const preparedParams: PreparedParam[] = []\n  for (let i = 0; i < value.length; i++) {\n    const preparedParam = prepareParam({ param, value: value[i] })\n    if (preparedParam.dynamic) dynamicChild = true\n    preparedParams.push(preparedParam)\n  }\n\n  if (dynamic || dynamicChild) {\n    const data = encodeParams(preparedParams)\n    if (dynamic) {\n      const length = numberToHex(preparedParams.length, { size: 32 })\n      return {\n        dynamic: true,\n        encoded: preparedParams.length > 0 ? concat([length, data]) : length,\n      }\n    }\n    if (dynamicChild) return { dynamic: true, encoded: data }\n  }\n  return {\n    dynamic: false,\n    encoded: concat(preparedParams.map(({ encoded }) => encoded)),\n  }\n}\n\ntype EncodeBytesErrorType =\n  | AbiEncodingBytesSizeMismatchErrorType\n  | ConcatErrorType\n  | PadHexErrorType\n  | NumberToHexErrorType\n  | SizeErrorType\n  | ErrorType\n\nfunction encodeBytes<const param extends AbiParameter>(\n  value: Hex,\n  { param }: { param: param },\n): PreparedParam {\n  const [, paramSize] = param.type.split('bytes')\n  const bytesSize = size(value)\n  if (!paramSize) {\n    let value_ = value\n    // If the size is not divisible by 32 bytes, pad the end\n    // with empty bytes to the ceiling 32 bytes.\n    if (bytesSize % 32 !== 0)\n      value_ = padHex(value_, {\n        dir: 'right',\n        size: Math.ceil((value.length - 2) / 2 / 32) * 32,\n      })\n    return {\n      dynamic: true,\n      encoded: concat([padHex(numberToHex(bytesSize, { size: 32 })), value_]),\n    }\n  }\n  if (bytesSize !== Number.parseInt(paramSize, 10))\n    throw new AbiEncodingBytesSizeMismatchError({\n      expectedSize: Number.parseInt(paramSize, 10),\n      value,\n    })\n  return { dynamic: false, encoded: padHex(value, { dir: 'right' }) }\n}\n\ntype EncodeBoolErrorType = PadHexErrorType | BoolToHexErrorType | ErrorType\n\nfunction encodeBool(value: boolean): PreparedParam {\n  if (typeof value !== 'boolean')\n    throw new BaseError(\n      `Invalid boolean value: \"${value}\" (type: ${typeof value}). Expected: \\`true\\` or \\`false\\`.`,\n    )\n  return { dynamic: false, encoded: padHex(boolToHex(value)) }\n}\n\ntype EncodeNumberErrorType = NumberToHexErrorType | ErrorType\n\nfunction encodeNumber(\n  value: number,\n  { signed, size = 256 }: { signed: boolean; size?: number | undefined },\n): PreparedParam {\n  if (typeof size === 'number') {\n    const max = 2n ** (BigInt(size) - (signed ? 1n : 0n)) - 1n\n    const min = signed ? -max - 1n : 0n\n    if (value > max || value < min)\n      throw new IntegerOutOfRangeError({\n        max: max.toString(),\n        min: min.toString(),\n        signed,\n        size: size / 8,\n        value: value.toString(),\n      })\n  }\n  return {\n    dynamic: false,\n    encoded: numberToHex(value, {\n      size: 32,\n      signed,\n    }),\n  }\n}\n\ntype EncodeStringErrorType =\n  | ConcatErrorType\n  | NumberToHexErrorType\n  | PadHexErrorType\n  | SizeErrorType\n  | SliceErrorType\n  | StringToHexErrorType\n  | ErrorType\n\nfunction encodeString(value: string): PreparedParam {\n  const hexValue = stringToHex(value)\n  const partsLength = Math.ceil(size(hexValue) / 32)\n  const parts: Hex[] = []\n  for (let i = 0; i < partsLength; i++) {\n    parts.push(\n      padHex(slice(hexValue, i * 32, (i + 1) * 32), {\n        dir: 'right',\n      }),\n    )\n  }\n  return {\n    dynamic: true,\n    encoded: concat([\n      padHex(numberToHex(size(hexValue), { size: 32 })),\n      ...parts,\n    ]),\n  }\n}\n\ntype EncodeTupleErrorType =\n  | ConcatErrorType\n  | EncodeParamsErrorType\n  // TODO: Add back once circular type reference is resolved\n  // | PrepareParamErrorType\n  | ErrorType\n\nfunction encodeTuple<\n  const param extends AbiParameter & { components: readonly AbiParameter[] },\n>(\n  value: AbiParameterToPrimitiveType<param>,\n  { param }: { param: param },\n): PreparedParam {\n  let dynamic = false\n  const preparedParams: PreparedParam[] = []\n  for (let i = 0; i < param.components.length; i++) {\n    const param_ = param.components[i]\n    const index = Array.isArray(value) ? i : param_.name\n    const preparedParam = prepareParam({\n      param: param_,\n      value: (value as any)[index!] as readonly unknown[],\n    })\n    preparedParams.push(preparedParam)\n    if (preparedParam.dynamic) dynamic = true\n  }\n  return {\n    dynamic,\n    encoded: dynamic\n      ? encodeParams(preparedParams)\n      : concat(preparedParams.map(({ encoded }) => encoded)),\n  }\n}\n\ntype GetArrayComponentsErrorType = ErrorType\n\nexport function getArrayComponents(\n  type: string,\n): [length: number | null, innerType: string] | undefined {\n  const matches = type.match(/^(.*)\\[(\\d+)?\\]$/)\n  return matches\n    ? // Return `null` if the array is dynamic.\n      [matches[2] ? Number(matches[2]) : null, matches[1]]\n    : undefined\n}\n","import type {\n  Abi,\n  AbiConstructor,\n  AbiError,\n  AbiEvent,\n  AbiEventParameter,\n  AbiFallback,\n  AbiFunction,\n  AbiParameter,\n  AbiReceive,\n  AbiStateMutability,\n} from '../abi.js'\nimport {\n  type FormatAbiParameters as FormatAbiParameters_,\n  formatAbiParameters,\n} from './formatAbiParameters.js'\nimport type { AssertName } from './types/signatures.js'\n\n/**\n * Formats ABI item (e.g. error, event, function) into human-readable ABI item\n *\n * @param abiItem - ABI item\n * @returns Human-readable ABI item\n */\nexport type FormatAbiItem<abiItem extends Abi[number]> =\n  Abi[number] extends abiItem\n    ? string\n    :\n        | (abiItem extends AbiFunction\n            ? AbiFunction extends abiItem\n              ? string\n              : `function ${AssertName<abiItem['name']>}(${FormatAbiParameters<\n                  abiItem['inputs']\n                >})${abiItem['stateMutability'] extends Exclude<\n                  AbiStateMutability,\n                  'nonpayable'\n                >\n                  ? ` ${abiItem['stateMutability']}`\n                  : ''}${abiItem['outputs']['length'] extends 0\n                  ? ''\n                  : ` returns (${FormatAbiParameters<abiItem['outputs']>})`}`\n            : never)\n        | (abiItem extends AbiEvent\n            ? AbiEvent extends abiItem\n              ? string\n              : `event ${AssertName<abiItem['name']>}(${FormatAbiParameters<\n                  abiItem['inputs']\n                >})`\n            : never)\n        | (abiItem extends AbiError\n            ? AbiError extends abiItem\n              ? string\n              : `error ${AssertName<abiItem['name']>}(${FormatAbiParameters<\n                  abiItem['inputs']\n                >})`\n            : never)\n        | (abiItem extends AbiConstructor\n            ? AbiConstructor extends abiItem\n              ? string\n              : `constructor(${FormatAbiParameters<\n                  abiItem['inputs']\n                >})${abiItem['stateMutability'] extends 'payable'\n                  ? ' payable'\n                  : ''}`\n            : never)\n        | (abiItem extends AbiFallback\n            ? AbiFallback extends abiItem\n              ? string\n              : `fallback() external${abiItem['stateMutability'] extends 'payable'\n                  ? ' payable'\n                  : ''}`\n            : never)\n        | (abiItem extends AbiReceive\n            ? AbiReceive extends abiItem\n              ? string\n              : 'receive() external payable'\n            : never)\n\ntype FormatAbiParameters<\n  abiParameters extends readonly (AbiParameter | AbiEventParameter)[],\n> = abiParameters['length'] extends 0\n  ? ''\n  : FormatAbiParameters_<\n      abiParameters extends readonly [\n        AbiParameter | AbiEventParameter,\n        ...(readonly (AbiParameter | AbiEventParameter)[]),\n      ]\n        ? abiParameters\n        : never\n    >\n\n/**\n * Formats ABI item (e.g. error, event, function) into human-readable ABI item\n *\n * @param abiItem - ABI item\n * @returns Human-readable ABI item\n */\nexport function formatAbiItem<const abiItem extends Abi[number]>(\n  abiItem: abiItem,\n): FormatAbiItem<abiItem> {\n  type Result = FormatAbiItem<abiItem>\n  type Params = readonly [\n    AbiParameter | AbiEventParameter,\n    ...(readonly (AbiParameter | AbiEventParameter)[]),\n  ]\n\n  if (abiItem.type === 'function')\n    return `function ${abiItem.name}(${formatAbiParameters(\n      abiItem.inputs as Params,\n    )})${\n      abiItem.stateMutability && abiItem.stateMutability !== 'nonpayable'\n        ? ` ${abiItem.stateMutability}`\n        : ''\n    }${\n      abiItem.outputs?.length\n        ? ` returns (${formatAbiParameters(abiItem.outputs as Params)})`\n        : ''\n    }`\n  if (abiItem.type === 'event')\n    return `event ${abiItem.name}(${formatAbiParameters(\n      abiItem.inputs as Params,\n    )})`\n  if (abiItem.type === 'error')\n    return `error ${abiItem.name}(${formatAbiParameters(\n      abiItem.inputs as Params,\n    )})`\n  if (abiItem.type === 'constructor')\n    return `constructor(${formatAbiParameters(abiItem.inputs as Params)})${\n      abiItem.stateMutability === 'payable' ? ' payable' : ''\n    }`\n  if (abiItem.type === 'fallback')\n    return `fallback() external${\n      abiItem.stateMutability === 'payable' ? ' payable' : ''\n    }` as Result\n  return 'receive() external payable' as Result\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport {\n  type ToSignatureHashErrorType,\n  toSignatureHash,\n} from './toSignatureHash.js'\n\nexport type ToEventSelectorErrorType = ToSignatureHashErrorType | ErrorType\n\n/**\n * Returns the event selector for a given event definition.\n *\n * @example\n * const selector = toEventSelector('Transfer(address indexed from, address indexed to, uint256 amount)')\n * // 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\n */\nexport const toEventSelector = toSignatureHash\n","export const arrayRegex = /^(.*)\\[([0-9]*)\\]$/\n\n// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n// https://regexr.com/6va55\nexport const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/\n\n// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n// https://regexr.com/6v8hp\nexport const integerRegex =\n  /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/\n","import type { ErrorType } from '../../errors/utils.js'\nimport { type ToBytesErrorType, toBytes } from '../encoding/toBytes.js'\nimport { type Keccak256ErrorType, keccak256 } from './keccak256.js'\n\nconst hash = (value: string) => keccak256(toBytes(value))\n\nexport type HashSignatureErrorType =\n  | Keccak256ErrorType\n  | ToBytesErrorType\n  | ErrorType\n\nexport function hashSignature(sig: string) {\n  return hash(sig)\n}\n","import { type AbiEvent, type AbiFunction, formatAbiItem } from 'abitype'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport {\n  type NormalizeSignatureErrorType,\n  normalizeSignature,\n} from './normalizeSignature.js'\n\nexport type ToSignatureErrorType = NormalizeSignatureErrorType | ErrorType\n\n/**\n * Returns the signature for a given function or event definition.\n *\n * @example\n * const signature = toSignature('function ownerOf(uint256 tokenId)')\n * // 'ownerOf(uint256)'\n *\n * @example\n * const signature_3 = toSignature({\n *   name: 'ownerOf',\n *   type: 'function',\n *   inputs: [{ name: 'tokenId', type: 'uint256' }],\n *   outputs: [],\n *   stateMutability: 'view',\n * })\n * // 'ownerOf(uint256)'\n */\nexport const toSignature = (def: string | AbiFunction | AbiEvent) => {\n  const def_ = (() => {\n    if (typeof def === 'string') return def\n    return formatAbiItem(def)\n  })()\n  return normalizeSignature(def_)\n}\n","import { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\n\ntype NormalizeSignatureParameters = string\ntype NormalizeSignatureReturnType = string\nexport type NormalizeSignatureErrorType = ErrorType\n\nexport function normalizeSignature(\n  signature: NormalizeSignatureParameters,\n): NormalizeSignatureReturnType {\n  let active = true\n  let current = ''\n  let level = 0\n  let result = ''\n  let valid = false\n\n  for (let i = 0; i < signature.length; i++) {\n    const char = signature[i]\n\n    // If the character is a separator, we want to reactivate.\n    if (['(', ')', ','].includes(char)) active = true\n\n    // If the character is a \"level\" token, we want to increment/decrement.\n    if (char === '(') level++\n    if (char === ')') level--\n\n    // If we aren't active, we don't want to mutate the result.\n    if (!active) continue\n\n    // If level === 0, we are at the definition level.\n    if (level === 0) {\n      if (char === ' ' && ['event', 'function', ''].includes(result))\n        result = ''\n      else {\n        result += char\n\n        // If we are at the end of the definition, we must be finished.\n        if (char === ')') {\n          valid = true\n          break\n        }\n      }\n\n      continue\n    }\n\n    // Ignore spaces\n    if (char === ' ') {\n      // If the previous character is a separator, and the current section isn't empty, we want to deactivate.\n      if (signature[i - 1] !== ',' && current !== ',' && current !== ',(') {\n        current = ''\n        active = false\n      }\n      continue\n    }\n\n    result += char\n    current += char\n  }\n\n  if (!valid) throw new BaseError('Unable to normalize signature.')\n\n  return result\n}\n","import type { AbiEvent, AbiFunction } from 'abitype'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport { type HashSignatureErrorType, hashSignature } from './hashSignature.js'\nimport { type ToSignatureErrorType, toSignature } from './toSignature.js'\n\nexport type ToSignatureHashErrorType =\n  | HashSignatureErrorType\n  | ToSignatureErrorType\n  | ErrorType\n\n/**\n * Returns the hash (of the function/event signature) for a given event or function definition.\n */\nexport function toSignatureHash(fn: string | AbiFunction | AbiEvent) {\n  return hashSignature(toSignature(fn))\n}\n"],"names":["docsPath","encodeFunctionData","parameters","args","abi","functionName","length","_parameters$functionN","startsWith","abiItem","item","getAbiItem","name","AbiFunctionNotFoundError","type","undefined","toFunctionSelector","formatAbiItem","prepareEncodeFunctionData","signature","data","inputs","encodeAbiParameters","concatHex","InvalidDomainError","BaseError","constructor","_ref","domain","super","concat","stringify","metaMessages","InvalidPrimaryTypeError","_ref2","primaryType","types","JSON","Object","keys","InvalidStructTypeError","_ref3","getTypesForEIP712Domain","version","chainId","verifyingContract","salt","filter","Boolean","validateReference","hashTypedData","message","_objectSpread","EIP712Domain","validateData","struct","param","value","integerMatch","match","integerRegex","_type","base","size_","numberToHex","signed","size","Number","parseInt","isAddress","InvalidAddressError","address","bytesMatch","bytesRegex","BytesSizeMismatchError","expectedSize","givenSize","validateTypedData","parts","push","hashStruct","hashDomain","keccak256","encoded","encodeData","encodedTypes","encodedValues","hashType","field","encodeField","_ref4","encodedHashType","toHex","_ref5","result","unsortedDeps","findTypeDependencies","delete","deps","Array","from","sort","map","_ref6","t","join","encodeType","_ref7","primaryType_","results","arguments","Set","has","add","_ref8","prepend","slice","lastIndexOf","parsedType","typeValuePairs","_ref9","_ref0","v","presignMessagePrefix","hashMessage","to_","message_","stringToHex","raw","bytesToHex","prefix","toPrefixedMessage","isSelector","isHex","strict","abiItems","toEventSelector","matchedAbiItem","every","arg","index","abiParameter","isArgOfType","ambiguousTypes","getAmbiguousTypes","AbiItemAmbiguityError","argType","abiParameterType","values","components","component","test","Uint8Array","isArray","x","replace","sourceParameters","targetParameters","parameterIndex","sourceParameter","targetParameter","includes","fn","toSignatureHash","execTyped","regex","string","exec","groups","isTupleRegex","arr","offset","set","concatBytes","reduce","acc","start","end","sliceHex","sliceBytes","assertStartOffset","SliceOffsetOutOfBoundsError","position","assertEndOffset","value_","includeName","InvalidDefinitionTypeError","formatAbiParams","params","formatAbiParam","AbiConstructorNotFoundError","AbiConstructorParamsNotFoundError","AbiDecodingDataSizeTooSmallError","defineProperty","this","AbiDecodingZeroDataError","AbiEncodingArrayLengthMismatchError","expectedLength","givenLength","AbiEncodingBytesSizeMismatchError","AbiEncodingLengthMismatchError","AbiErrorInputsNotFoundError","errorName","AbiErrorNotFoundError","AbiErrorSignatureNotFoundError","AbiEventSignatureEmptyTopicsError","AbiEventSignatureNotFoundError","_ref1","AbiEventNotFoundError","eventName","AbiFunctionOutputsNotFoundError","_ref10","AbiFunctionSignatureNotFoundError","_ref11","y","_ref12","DecodeLogDataMismatch","_ref13","DecodeLogTopicsMismatch","_ref14","InvalidAbiEncodingTypeError","_ref15","InvalidAbiDecodingTypeError","_ref16","InvalidArrayError","UnsupportedPackedAbiType","tupleRegex","_wrapRegExp","array","formatAbiParameter","_result$array","i","indexed","formatAbiParameters","abiParameters","preparedParams","prepareParam","prepareParams","encodeParams","arrayComponents","getArrayComponents","dynamic","dynamicChild","preparedParam","encodeArray","param_","encodeTuple","padHex","toLowerCase","encodeAddress","boolToHex","encodeBool","_integerRegex$exec","max","BigInt","min","IntegerOutOfRangeError","toString","encodeNumber","paramSize","split","bytesSize","dir","Math","ceil","encodeBytes","hexValue","partsLength","encodeString","staticSize","staticParams","dynamicParams","dynamicSize","matches","_abiItem$outputs","stateMutability","outputs","arrayRegex","hash","toBytes","toSignature","def","active","current","level","valid","char","normalizeSignature","sig"],"sourceRoot":""}